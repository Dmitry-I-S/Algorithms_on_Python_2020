# Подсчитать, сколько было выделено памяти под переменные в ранее разработанных программах в рамках первых трех уроков.
# Проанализировать результат и определить программы с наиболее эффективным использованием памяти.
# Примечание: По аналогии с эмпирической оценкой алгоритмов идеальным решением будет:
#
# ● выбрать хорошую задачу, которую имеет смысл оценивать по памяти;
# ● написать 3 варианта кода (один у вас уже есть);
# ● проанализировать 3 варианта и выбрать оптимальный;
# ● результаты анализа (количество занятой памяти в вашей среде разработки) вставить в виде комментариев в файл с кодом.
# Не забудьте указать версию и разрядность вашей ОС и интерпретатора Python;
# ● написать общий вывод: какой из трёх вариантов лучше и почему.
# Надеемся, что вы не испортили программы, добавив в них множество sys.getsizeof после каждой переменной, а проявили творчество, фантазию и создали универсальный код для замера памяти.

# 3. Сформировать из введенного числа обратное по порядку входящих в него цифр и вывести на экран.
# Например, если введено число 3486, надо вывести 6843.
from collections import deque
import sys


# Упрощенная функция для подсчета памяти, потраченных на объекты, исключая списки с переменными и словари:
def memory_sum(x, sum_list):
    """Считает память, потираченную на переменную х и добавляет ее в список sum_list"""
    sum_ = sys.getsizeof(x)
    if hasattr(x, '__iter__') and not isinstance(x, str):
        for i in x:
            sum_ += sys.getsizeof(i)  # достаточно одного вызова функции, т.к. в задаче не будет списков с переменными
    sum_list.append(sum_)
    return sum_list


NUMBER = input('Введите натуральное число: ')       # одно число для всех задач

# *****************************************************
# Вариант 1 - стандартное арифметическое решение урока
sum_1 = []          # список для сбора значений задействанной памяти

num = NUMBER
memory_sum(num, sum_1)

num = int(num)
memory_sum(num, sum_1)

num_rev_1 = 0
memory_sum(num_rev_1, sum_1)

while num > 0:
    c = num % 10
    num = num // 10
    num_rev_1 = int(num_rev_1 * 10 + c)

memory_sum(c, sum_1)            # Добавляем переменные, которые менялись в цикле, но только один раз - по условию ДЗ
memory_sum(num, sum_1)          # Добавляем переменные, которые менялись в цикле, но только один раз - по условию ДЗ
memory_sum(num_rev_1, sum_1)    # Добавляем переменные, которые менялись в цикле, но только один раз - по условию ДЗ

# *****************************************************
# Вариант 2 - решение с очередью из коллекций
sum_2 = []

num = NUMBER
memory_sum(num, sum_2)

num = deque(num)
memory_sum(num, sum_2)

num.reverse()
memory_sum(num, sum_2)

num_rev_2 = int(('').join(num))
memory_sum(num_rev_2, sum_2)


# *****************************************************
# Вариант 3 - решение со сложением строк
sum_3 = []

num = NUMBER
memory_sum(num, sum_3)

num_rev_3 = ''
memory_sum(num_rev_3, sum_3)

for i in range(len(num) - 1, -1, -1):
    num_rev_3 += num[i]

# Очениваем переменные в цикле по одному разу:
memory_sum(range(len(num) - 1, -1, -1), sum_3)
memory_sum(num_rev_3, sum_3)
memory_sum(num[i], sum_3)

num_rev_3 = int(num_rev_3)
memory_sum(num_rev_3, sum_3)


# *****************************************************
# Анализ решений

the_best = min(sum(sum_1), sum(sum_2), sum(sum_3))

if num_rev_1 == num_rev_2 == num_rev_3:
    print(f'Все решения дают одинаковый результат - {num_rev_3}')
else:
    print(f'Все решенияне дают одинаковый результат')

print(f'Результаты работы решений - использованная память: {sum(sum_1), sum(sum_2), sum(sum_3)}')
print(f'Результаты работы в виду списков: {sum_1, sum_2, sum_3}')
print(f'Лучший результат: {the_best}')
# Версия Питон 3.7 pip	10.0.1, и разрядность системы 32
# Все решения дают одинаковый результат для ичсла 123456789 - 987654321
# Результаты работы решений - использованная память: (104, 1158, 283)
# Лучший результат: 104
# Наименьший объем памяти для переменных оказалась у Решения 1 - использование арифметических опрепаций и цикла while,
# кол-во циклов = кол-ву чисел
# Худший результат - Решение 2 с использованием Очереди из коллекций. Сами очереди занимают большое кол-во памяти.
# Средний результат показало Решшение 2, где мы использовали свойства строк, как итерируемых объектов.
# Это также сьело больше памяти, чем арифметика.

# Но в цикле арифметического решения 1 создаются целых 3 переменных за 1 итерацию, а оценивали их только один раз...
# Поэтому остаются смутные сомнения...
